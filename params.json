{"name":"Sponges","tagline":"Turn any Ruby object into a daemon controlling an army of sponges.","body":"[![Code\r\nClimate](https://codeclimate.com/badge.png)](https://codeclimate.com/github/AF83/sponges)\r\n[![Gem\r\nVersion](https://fury-badge.herokuapp.com/rb/sponges.png)](http://badge.fury.io/rb/sponges)\r\n\r\nWhen I build workers, I want them to be like an army of spongebobs, always\r\nstressed and eager to work. `sponges` helps you build this army of sponges, to\r\ncontrol them, and, well, to kill them gracefully. Making them stressed and eager\r\nto work is your job. :)\r\n\r\nBasically, sponges is a ruby supervisor that forks processes and controls their\r\nexecution and termination. For example the following will start a supervision\r\ndaemon and 8 processes of  \"a_worker\".\r\n\r\n```bash\r\nruby a_worker.rb start -d -s 8\r\n```\r\nIf you kill the supervisor it will cleanly\r\nterminate the child processes.\r\n\r\nInternally, `sponges` strongly relies on Unix signals.\r\n\r\n## Installation\r\n\r\nRuby 1.9.2 (or superior).\r\n\r\nInstall it with rubygems:\r\n\r\n    gem install sponges\r\n\r\nWith bundler, add it to your `Gemfile`:\r\n\r\n``` ruby\r\ngem \"sponges\"\r\n```\r\n\r\n## Usage\r\nIn a file called `example.rb`:\r\n\r\n``` ruby\r\n# The worker class is the one you want to daemonize.\r\n#\r\nrequire 'sponges'\r\n\r\nclass Worker\r\n  def initialize\r\n    # Trap the HUP signal, set a boolean to true.\r\n    trap(:HUP) {\r\n      Sponges.logger.info \"HUP signal trapped, clean stop.\"\r\n      @hup = true\r\n    }\r\n  end\r\n\r\n  def run\r\n    Sponges.logger.info Process.pid\r\n    if @hup # is true, we need to shutdown this worker\r\n      Sponges.logger.info \"HUP signal trapped, shutdown...\"\r\n      exit 0 # everything's fine, we can exit\r\n    else # this worker can continue its work\r\n      sleep rand(20)\r\n      run\r\n    end\r\n  end\r\nend\r\n\r\nSponges.configure do |config|\r\n  config.logger            = MyCustomLogger.new   # optionnal\r\n  config.redis             = Redis.new            # optionnal\r\n  config.size              = 3                    # optionnal, default to cpu's size\r\n  config.daemonize         = true                 # optionnal, default to false\r\n  config.port              = 5032                 # optionnal, default to 5032\r\n  config.after_fork do\r\n    puts \"Execute code when a child process is created\"\r\n  end\r\n  config.on_chld do\r\n    puts \"Execute code when a child process is killed\"\r\nend\r\n\r\n# Register a pool named \"worker_name\".\r\n#\r\nSponges.start \"worker_name\" do\r\n  Worker.new({some: args}).run\r\nend\r\n```\r\nSee the help message :\r\n``` bash\r\nruby example.rb\r\n```\r\n\r\nStart workers :\r\n``` bash\r\nruby example.rb start\r\n```\r\n\r\nStart workers and daemonize them:\r\n``` bash\r\nruby example.rb start -d\r\n```\r\n\r\nStart 8 instances of the worker and daemonize them:\r\n``` bash\r\nruby example.rb start -d -s 8 # By default, size equals cpu core's size.\r\n```\r\n\r\nRetart gracefully 4 instances of the worker, with a timeout of 3 seconds and\r\ndaemonize them:\r\n``` bash\r\nruby example.rb restart -g -s 4 -t 3\r\n```\r\n\r\nStop workers with a `QUIT` signal :\r\n``` bash\r\nruby example.rb stop\r\n```\r\n\r\nStop workers with a `KILL` signal :\r\n``` bash\r\nruby example.rb kill\r\n```\r\n\r\nStop workers with a `HUP` signal :\r\n``` bash\r\nruby example.rb stop -g -t 5\r\n```\r\nIn this case, you will have to trap the `HUP` signal, and handle a clean stop\r\nfrom each workers. The point is to wait for a task to be done before quitting. A\r\ntimeout can be specify with the `-t` option. When this timeout is hited, the\r\nprocess is killed.\r\n\r\nIncrement worker's pool size :\r\n``` bash\r\nruby example.rb increment # will add a worker to the pool.\r\n```\r\n\r\nDecrement worker's pool size :\r\n``` bash\r\nruby example.rb decrement # will remove a worker to the pool.\r\n```\r\n\r\nShow a list of workers and their children.\r\n``` bash\r\nruby example.rb list\r\n```\r\n\r\n## Http supervision\r\n\r\nsponges provides an http interface to supervise pool's activity, and to expose\r\npids. Http supervision can be enable in configuration:\r\n\r\n\r\n``` ruby\r\nSponges.configure do |config|\r\n  config.port            = 3333\r\nend\r\n```\r\n\r\nBy default, sponges listens on port 5032, and responds in json. Here is an\r\nexample of response:\r\n\r\n``` javascript\r\n{\r\n  \"supervisor\":{\r\n    \"pid\":11537,\r\n    \"pctcpu\":0.0,\r\n    \"pctmem\":0.22,\r\n    \"created_at\":\"2013-03-05 15:21:04 +0100\"\r\n  },\r\n  \"children\":[\r\n    {\r\n      \"pid\":11540,\r\n      \"pctcpu\":0.0,\r\n      \"pctmem\":0.21,\r\n      \"created_at\":\"2013-03-05 15:21:04 +0100\"\r\n    },\r\n    {\r\n      \"pid\":11543,\r\n      \"pctcpu\":0.0,\r\n      \"pctmem\":0.21,\r\n      \"created_at\":\"2013-03-05 15:21:04 +0100\"\r\n    },\r\n    {\r\n      \"pid\":11546,\r\n      \"pctcpu\":0.0,\r\n      \"pctmem\":0.21,\r\n      \"created_at\":\"2013-03-05 15:21:04 +0100\"\r\n    },\r\n    {\r\n      \"pid\":11549,\r\n      \"pctcpu\":0.0,\r\n      \"pctmem\":0.21,\r\n      \"created_at\":\"2013-03-05 15:21:04 +0100\"\r\n    }\r\n  ]\r\n}\r\n```\r\n\r\n## Stores\r\n\r\nsponges can store pids in memory or in redis. Memory is the default store. The\r\n`list` command is not available with the memory store.\r\n\r\nTo select the redis store, you need to add `nest` to your application's\r\nGemfile, and do the following.\r\n\r\n``` ruby\r\ngem \"nest\"\r\n```\r\n\r\n``` ruby\r\nSponges.configure do |config|\r\n  config.store         = :redis\r\nend\r\n```\r\n\r\n## Roadmap\r\n\r\n### Version 1.0\r\n\r\n * Removal of Redis store\r\n\r\n## Changelog\r\n\r\n### Version 0.6\r\n\r\n * Deprecation notice about Redis store removal\r\n * Ruby 2.0 compatibility: rework signal handler. 2.0 does not allow the use of\r\n a mutex in a trap. For now on, a pipe is use to comunicate signal to the\r\n handler. This has also enforce signal handler to be synchrone.\r\n * `restart` now daemonize process by default\r\n\r\n### Version 0.7\r\n\r\n * Inclusion of Http supervision\r\n\r\n\r\n## Acknowledgements\r\n\r\nsponges would not have been the same without [Jesse\r\nStorimer](https://github.com/jstorimer) and his awesome book about\r\n[Unix](http://workingwithunixprocesses.com/).\r\n\r\n## Copyright\r\n\r\nMIT. See LICENSE for further details.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}