<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Sponges by AF83</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Sponges</h1>
          <h2>Turn any Ruby object into a daemon controlling an army of sponges.</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/AF83/sponges/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/AF83/sponges/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/AF83/sponges" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <p>When I build workers, I want them to be like an army of spongebobs, always
stressed and eager to work. <code>sponges</code> helps you build this army of sponges, to
control them, and, well, to kill them gracefully. Making them stressed and eager
to work is your job. :)</p>

<p>Basically, sponges is a ruby supervisor that forks processes and controls their
execution and termination. For example the following will start a supervision
daemon and 8 processes of  "a_worker".</p>

<div class="highlight"><pre>ruby a_worker.rb start -d -s 8
</pre></div>

<p>If you kill the supervisor it will cleanly
terminate the child processes.</p>

<p>Internally, <code>sponges</code> strongly relies on Unix signals.</p>

<h2>Installation</h2>

<p>Ruby 1.9.2 (or superior).</p>

<p>Install it with rubygems:</p>

<pre><code>gem install sponges
</code></pre>

<p>With bundler, add it to your <code>Gemfile</code>:</p>

<div class="highlight"><pre><span class="n">gem</span> <span class="s2">"sponges"</span>
</pre></div>

<h2>Usage</h2>

<p>In a file called <code>example.rb</code>:</p>

<div class="highlight"><pre><span class="c1"># The worker class is the one you want to daemonize.</span>
<span class="c1">#</span>
<span class="nb">require</span> <span class="s1">'sponges'</span>

<span class="k">class</span> <span class="nc">Worker</span>
  <span class="k">def</span> <span class="nf">run</span>
    <span class="c1"># Trap the HUP signal, set a boolean to true.</span>
    <span class="nb">trap</span><span class="p">(</span><span class="ss">:HUP</span><span class="p">)</span> <span class="p">{</span>
      <span class="no">Sponges</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"HUP signal trapped, clean stop."</span>
      <span class="vi">@hup</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="p">}</span>
    <span class="no">Sponges</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="no">Process</span><span class="o">.</span><span class="n">pid</span>
    <span class="k">if</span> <span class="vi">@hup</span> <span class="c1"># is true, we need to shutdown this worker</span>
      <span class="no">Sponges</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span> <span class="s2">"HUP signal trapped, shutdown..."</span>
      <span class="nb">exit</span> <span class="mi">0</span> <span class="c1"># everything's fine, we can exit</span>
    <span class="k">else</span> <span class="c1"># this worker can continue its work</span>
      <span class="nb">sleep</span> <span class="nb">rand</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
      <span class="n">run</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">Sponges</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">logger</span>        <span class="o">=</span> <span class="no">MyCustomLogger</span><span class="o">.</span><span class="n">new</span>   <span class="c1"># optionnal</span>
  <span class="n">config</span><span class="o">.</span><span class="n">redis</span>         <span class="o">=</span> <span class="no">Redis</span><span class="o">.</span><span class="n">new</span>            <span class="c1"># optionnal</span>
  <span class="n">config</span><span class="o">.</span><span class="n">size</span>          <span class="o">=</span> <span class="mi">3</span>
  <span class="n">config</span><span class="o">.</span><span class="n">daemonize</span>     <span class="o">=</span> <span class="kp">true</span>
  <span class="n">config</span><span class="o">.</span><span class="n">after_fork</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s2">"Execute code when a child process is created"</span>
  <span class="k">end</span>
  <span class="n">config</span><span class="o">.</span><span class="n">on_chld</span> <span class="k">do</span>
    <span class="nb">puts</span> <span class="s2">"Execute code when a child process is killed"</span>
<span class="k">end</span>

<span class="c1"># Register a pool named "worker_name".</span>
<span class="c1">#</span>
<span class="no">Sponges</span><span class="o">.</span><span class="n">start</span> <span class="s2">"worker_name"</span> <span class="k">do</span>
  <span class="no">Worker</span><span class="o">.</span><span class="n">new</span><span class="p">({</span><span class="n">some</span><span class="p">:</span> <span class="n">args</span><span class="p">})</span><span class="o">.</span><span class="n">run</span>
<span class="k">end</span>
</pre></div>

<p>See the help message :</p>

<div class="highlight"><pre>ruby example.rb
</pre></div>

<p>Start workers :</p>

<div class="highlight"><pre>ruby example.rb start
</pre></div>

<p>Start workers and daemonize them:</p>

<div class="highlight"><pre>ruby example.rb start -d
</pre></div>

<p>Start 8 instances of the worker and daemonize them:</p>

<div class="highlight"><pre>ruby example.rb start -d -s 8 <span class="c"># By default, size equals cpu core's size.</span>
</pre></div>

<p>Retart gracefully 4 instances of the worker, with a timeout of 3 seconds and
daemonize them:</p>

<div class="highlight"><pre>ruby example.rb restart -g -d -s 4 -t 3
</pre></div>

<p>Stop workers with a <code>QUIT</code> signal :</p>

<div class="highlight"><pre>ruby example.rb stop
</pre></div>

<p>Stop workers with a <code>KILL</code> signal :</p>

<div class="highlight"><pre>ruby example.rb <span class="nb">kill</span>
</pre></div>

<p>Stop workers with a <code>HUP</code> signal :</p>

<div class="highlight"><pre>ruby example.rb stop -g -t 5
</pre></div>

<p>In this case, you will have to trap the <code>HUP</code> signal, and handle a clean stop
from each workers. The point is to wait for a task to be done before quitting. A
timeout can be specify with the <code>-t</code> option. When this timeout is hited, the
process is killed.</p>

<p>Increment worker's pool size :</p>

<div class="highlight"><pre>ruby example.rb increment <span class="c"># will add a worker to the pool.</span>
</pre></div>

<p>Decrement worker's pool size :</p>

<div class="highlight"><pre>ruby example.rb decrement <span class="c"># will remove a worker to the pool.</span>
</pre></div>

<p>Show a list of workers and their children.</p>

<div class="highlight"><pre>ruby example.rb list
</pre></div>

<h2>Stores</h2>

<p>sponges can store pids in memory or in redis. Memory is the default store. The
<code>list</code> command is not available with the memory store.</p>

<p>To select the redis store, you need to add <code>nest</code> to your application's
Gemfile, and do the following.</p>

<div class="highlight"><pre><span class="n">gem</span> <span class="s2">"sponges"</span>
</pre></div>

<div class="highlight"><pre><span class="no">Sponges</span><span class="o">.</span><span class="n">configure</span> <span class="k">do</span> <span class="o">|</span><span class="n">config</span><span class="o">|</span>
  <span class="n">config</span><span class="o">.</span><span class="n">store</span>         <span class="o">=</span> <span class="ss">:redis</span>
<span class="k">end</span>
</pre></div>

<h2>Roadmap</h2>

<h3>Version 0.6</h3>

<ul>
<li>Deprecation notice about Redis store removal</li>
</ul><h3>Version 0.7</h3>

<ul>
<li>Inclusion of Http supervision</li>
</ul><h3>Version 1.0</h3>

<ul>
<li>Removal of Redis store</li>
</ul><h2>Acknowledgements</h2>

<p>sponges would not have been the same without <a href="https://github.com/jstorimer">Jesse
Storimer</a> and his awesome book about
<a href="http://workingwithunixprocesses.com/">Unix</a>.</p>
        </section>

        <footer>
          Sponges is maintained by <a href="https://github.com/AF83">AF83</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
        </footer>

        
      </div>
    </div>
  </body>
</html>